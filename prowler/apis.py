# -*- coding: utf-8 -*-


import requests as rq
import pandas as pd
from tqdm import tqdm


class KEGG_API:
    """Provides connectivity with the KEGG database. Functions ending with <tbl>
    download files provided by KEGG but DO NOT modify them. Modifications
    needed for data processing are made on pandas.DataFrame.
    """
    def __init__(self):
        self.home = "http://rest.kegg.jp"
        self.operations = {"db_statistics": "info",
                           "list_entry_ids": "list",
                           "find_by_keyword": "find",
                           "get_by_entry_no": "get",
                           "conv_2_outside_ids": "conv",
                           "find_X_ref": "link"}
        self.databases = {"pathway": "path",
                          "brite": "br",
                          "module": "md",
                          "orthology": "ko",
                          "genome": "genome",
                          "genomes": "gn",
                          "ligand": "ligand",
                          "compound": "cpd",
                          "glycan": "gl",
                          "reaction": "rn",
                          "rpair": "rp",
                          "rclass": "rc",
                          "enzyme": "ec",
                          "disease": "ds",
                          "drug": "dr",
                          "dgroup": "dg",
                          "environ": "ev"}
        self.organisms_ids_df = None
        self.id_conversions = {"ncbi_gene": "ncbi-geneid",
                               "ncbi_prot": "ncbi-proteinid",
                               "uniprot": "uniprot",
                               "kegg_id": "genes"}
        self.id_conversions_df = None
        self.org_db_X_ref_df = None
        self.query_ids_not_found = []

    def get_organisms_ids(self,
                          out_file_name,
                          skip_dwnld=False):
        """Get KEGG's organisms' IDs, genomes IDs and definitions. Data are
        downloaded to a local file and then made into pandas.DataFrame. File
        can be reused. Necessary for KEGG_API.org_name_2_kegg_id.

        Args:
            out_file_name (str): name for file to be downloaded
            skip_dwnld (bool): read existing file when <True>. Default <False>
        """
        if skip_dwnld is True:
            pass
        else:
            url = "{0}/{1}/{2}".format(self.home,
                                       self.operations["list_entry_ids"],
                                       self.databases["genome"])
            res = rq.get(url)
            with open(out_file_name, "w") as fout:
                fout.write(res.content)
        self.organisms_ids_df = pd.read_csv(out_file_name,
                                            names=["genome_id",
                                                   "names",
                                                   "description"],
                                            header=None,
                                            sep="\t|;",
                                            engine="python",
                                            error_bad_lines=False,
                                            warn_bad_lines=True)
        temp_sub_df = self.organisms_ids_df["names"].str.split(",", expand=True)
        temp_sub_df.columns = ["kegg_org_id", "name", "taxon_id"]
        self.organisms_ids_df.drop("names", axis=1, inplace=True)
        self.organisms_ids_df = pd.concat([self.organisms_ids_df, temp_sub_df], axis=1)
        self.organisms_ids_df.replace({"genome:": ""},
                                      regex=True,
                                      inplace=True)
        self.organisms_ids_df.dropna(inplace=True)

    def org_name_2_kegg_id(self,
                           organism,
                           assume_1st=True):
        """Return KEGG's organisms' IDs (str) when queried  with a regular
        (natural) biological name. Case-sensitive. Uses KEGG_API.organisms_ids_df
        generated by KEGG_API.get_organisms_ids. Necessary for creation of ids
        list which is then passed to Genome.KO_list_profiler.

        Args:
            organism (str): biological organism's name to query against
            the KEGG's IDs
            assume_1st (bool): return the first item if more than one hit when
            <True> (default)
        """
        org_bool = self.organisms_ids_df.description.str.contains(organism)
        organism_ser = self.organisms_ids_df[org_bool]
        if len(organism_ser) == 0:
            print "No record found for {}".format(organism)
            self.query_ids_not_found.append(organism)
        elif len(organism_ser) > 1:
            if assume_1st is True:
                return organism_ser.kegg_org_id.iloc[0]
            print "More than one record for this query\n{}".format(organism_ser[["description",
                                                                                 "kegg_org_id"]])
        else:
            return str(organism_ser.kegg_org_id.to_string(index=False,
                                                          header=False))

    def get_id_conv_tbl(self,
                        source_id_type,
                        organism,
                        out_file_name,
                        skip_dwnld=False,
                        strip_pref=True):
        """Get genes or proteins IDs to KEGG IDs convertion table in
        pandas.DataFrame format. Data are downloaded to a local file and then
        made into pandas.DataFrame. File can be reused.

        Args:
            source_id_type (str): determines type of the source IDs
            organism (str): determines name of the organism bounded to the
            source IDs
            out_file_name (str): name for file to be downloaded
            skip_dwnld (bool) = read existing file when <True>. Default <False>
        """
        org_id = self.org_name_2_kegg_id(organism)
        if skip_dwnld is True:
            pass
        else:
            url = "{0}/{1}/{2}/{3}".format(self.home,
                                           self.operations["conv_2_outside_ids"],
                                           self.id_conversions[source_id_type],
                                           org_id)
            res = rq.get(url)
            with open(out_file_name, "w") as fout:
                fout.write(res.content)
        self.id_conversions_df = pd.read_csv(out_file_name,
                                             names=[source_id_type,
                                                    "kegg_id"],
                                             header=None,
                                             sep="\t")
        if strip_pref is True:
            self.id_conversions_df.replace({"{0}:".format(org_id): ""},
                                           regex=True,
                                           inplace=True)
            self.id_conversions_df.replace({"{0}:".format(self.id_conversions[source_id_type]): ""},
                                           regex=True,
                                           inplace=True)
        else:
            pass

    def get_org_db_X_ref(self,
                         organism,
                         target_db,
                         out_file_name,
                         skip_dwnld=False,
                         strip_prefix=True):
        """Get desired KEGG's database entries linked with all the genes from
        given organism. Data are downloaded to a local file and then made into
        pandas.DataFrame. File can be reused. Necessary for
        KEGG_API.get_ortho_db_entries and Ortho_Interactions.KO_based_appender.

        Args:
            organism (str): organism name. Provide whitespace-separated full
            species name. Uses pandas.series.str.contains method.
            targed_db (str): dict key for KEGG_API.databases of desired
            database.
            out_file_name (str): name for file to be downloaded
            skip_dwnld (bool) = read existing file when <True>. Default <False>
        """
        org_id = self.org_name_2_kegg_id(organism)
        if skip_dwnld is True:
            pass
        else:
            url = "{0}/{1}/{2}/{3}".format(self.home,
                                           self.operations["find_X_ref"],
                                           self.databases[target_db],
                                           org_id)
            res = rq.get(url)
            with open(out_file_name, "w") as fout:
                fout.write(res.content)
        self.org_db_X_ref_df = pd.read_csv(out_file_name,
                                           names=["ORF_id", "kegg_id"],
                                           header=None,
                                           sep="\t")
        if strip_prefix is True:
            self.org_db_X_ref_df.replace({"{}:".format(org_id): "",
                                          "{}:".format(self.databases[target_db]): ""},
                                         regex=True,
                                         inplace=True)

    def get_db_entries(self,
                       out_file_name):
        """Get full database by quering entries from
        KEGG_API.org_db_X_ref_df and download them into a local file.
        Necessary for Genome.parse_KO_db. The only func that does NOT convert
        downloaded file into pandas.DataFrame. Uses KEGG_API.get_db_X_ref_df.

        Args:
            out_file_name (str): name for file to be downloaded
        """
        entries = self.org_db_X_ref_df["kegg_id"].drop_duplicates()
        for i in tqdm(entries):
            url = "{0}/{1}/{2}".format(self.home,
                                       self.operations["get_by_entry_no"],
                                       i)
            res = rq.get(url)
            with open(out_file_name, "a") as fout:
                fout.write(res.content)


class Costanzo_API:
    """Provides connectivity with the Costanzo's SOM website of the Genetic
    Landscape of the Cell project, allowing data files download.

    Attribs:
        home (str): Costanzo's SOM home page address
        raw (str): raw data link and file name
        raw_matrix (str): raw data genetic interactions matrix link and file
        name, Java Treeview format
        lenient_cutoff (str): GIS_P < 0.05 cutoff link and file name
        intermediate_cutoff (str): |genetic interaction score| > 0.08,
        GIS_P < 0.05 cutoff link and file name
        stringent_cutoff (str): genetic interaction score < -0.12,
        GIS_P < 0.05 or genetic interaction score > 0.16, GIS_P < 0.05 link
        and file name
        bioprocesses (str): bioprocesses annotations
        chemical_genomics (str): chemical genomics data
        query_list (str): query ORFs list
        array_list (str): array ORFs list
    """

    def __init__(self):
        self.home = "http://drygin.ccbr.utoronto.ca/~costanzo2009"
        self.raw = "sgadata_costanzo2009_rawdata_101120.txt.gz"
        self.raw_matrix = "sgadata_costanzo2009_rawdata_matrix_101120.txt.gz"
        self.lenient_cutoff = "sgadata_costanzo2009_lenientCutoff_101120.txt.gz"
        self.intermediate_cutoff = "sgadata_costanzo2009_intermediateCutoff_101120.txt.gz"
        self.stringent_cutoff = "sgadata_costanzo2009_stringentCutoff_101120.txt.gz"
        self.bioprocesses = "bioprocess_annotations_costanzo2009.xls"
        self.chemical_genomics = "chemgenomic_data_costanzo2009.xls"
        self.query_list = "sgadata_costanzo2009_query_list_101120.txt"
        self.array_list = "sgadata_costanzo2009_array_list.txt"

    def get_data(self,
                 data):
        """Get files from Costanzo's SOM website.

        Args:
            data (str): specifies the file to be downloaded.
            <raw> for raw dataset,
            <raw_matrix> for raw genetic interactions matrix,
            <lenient_cutoff> for lenient dataset,
            <intermediate_cutoff> for intermediate dataset,
            <stringent_cutoff> for stringent dataset,
            <bioprocesses> for bioprocesses dataset,
            <chemical_genomics> for chemical genomics dataset,
            <query_list> for list of query ORFs names,
            <array_list> for list of array ORFs names
            out_file_name (str): name for file to be downloaded. Automatically
            same as appropriate Costanzo_API attrib when set to <None>
        """
        if data == "raw":
            url = "{0}/{1}".format(self.home,
                                   self.raw)
            out_file_name = self.raw
        elif data == "raw_matrix":
            url = "{0}/{1}".format(self.home,
                                   self.raw_matrix)
            out_file_name = self.raw_matrix
        elif data == "lenient_cutoff":
            url = "{0}/{1}".format(self.home,
                                   self.lenient_cutoff)
            out_file_name = self.lenient_cutoff
        elif data == "intermediate_cutoff":
            url = "{0}/{1}".format(self.home,
                                   self.intermediate_cutoff)
            out_file_name = self.intermediate_cutoff
        elif data == "stringent_cutoff":
            url = "{0}/{1}".format(self.home,
                                   self.stringent_cutoff)
            out_file_name = self.stringent_cutoff
        elif data == "bioprocesses":
            url = "{0}/{1}".format(self.home,
                                   self.bioprocesses)
            out_file_name = self.bioprocesses
        elif data == "chemical_genomics":
            url = "{0}/{1}".format(self.home,
                                   self.chemical_genomics)
            out_file_name = self.chemical_genomics
        elif data == "query_list":
            url = "{0}/{1}".format(self.home,
                                   self.query_list)
            out_file_name = self.query_list
        elif data == "array_list":
            url = "{0}/{1}".format(self.home,
                                   self.array_list)
            out_file_name = self.array_list
        else:
            raise ValueError("unknown option for data arg")
        res = rq.get(url)
        with open(out_file_name, "w") as fout:
            fout.write(res.content)
